<?php declare(strict_types=1);

namespace AP\HttpServer;

use AP\Cache\Persistent\PersistentCacheInterface;
use AP\HttpServer\BaseServer\Nginx;
use AP\HttpServer\BaseServer\ServerInterface;
use AP\Logger\Log;
use AP\Routing\Request\Method;
use AP\Routing\Request\Request;
use AP\Routing\Response\Handler\BaseResponseHandler;
use AP\Routing\Response\Handler\ResponseHandlerInterface;
use AP\Routing\Response\Response;
use AP\Routing\Routing\Endpoint;
use AP\Routing\Routing\Exception\NotFound;
use AP\Routing\Routing\Routing\Hashmap\Hashmap;
use AP\Routing\Routing\Routing\RoutingInterface;
use Generator;
use Throwable;

readonly class HttpServer
{
    const string LOG_MODULE_NAME   = 'ap:http-server';
    const string CONTEXT_EXCEPTION = 'HttpServerException';

    protected RoutingInterface $routing;
    protected ServerInterface  $webServer;
    protected string           $path;
    protected Method           $method;

    /**
     * Initializes the HTTP server with routing, request handling, and execution components
     *
     * @param PersistentCacheInterface|array $indexCache The cached routing index, either as an array or a persistent cache interface
     * @param RoutingInterface|null $routing Optional routing instance, defaults to a Hashmap if null
     * @param ServerInterface|null $webServer Optional web server handler, defaults to Nginx if null
     * @param ResponseHandlerInterface|null $responseHandler Optional request handler interface
     * @param Endpoint|null $notFoundEndpoint Custom endpoint for handling 404 Not Found responses
     * @param Endpoint|null $internalServerErrorEndpoint Custom endpoint for handling 500 Internal Server Error responses
     * @param bool $earlyFinishRequest Whether to close the client connection before executing post-response tasks
     *      Set to `true` (default) for improved performance by allowing background processing after the client connection is closed.
     *      Set to `false` if debugging is necessary, especially when logging errors directly to the console before the request is finished.
     */
    public function __construct(
        PersistentCacheInterface|array      $indexCache,
        ?RoutingInterface                   $routing = null,
        ?ServerInterface                    $webServer = null,
        protected ?ResponseHandlerInterface $responseHandler = new BaseResponseHandler(),
        protected ?Endpoint                 $notFoundEndpoint = null,
        protected ?Endpoint                 $internalServerErrorEndpoint = null,
        protected bool                      $earlyFinishRequest = true,
    )
    {
        $this->routing   = is_null($routing) ? new Hashmap() : $routing;
        $this->webServer = is_null($webServer) ? new Nginx() : $webServer;
        $this->path      = $this->webServer->parsePath();
        $this->method    = $this->webServer->parseMethod();

        try {
            if (is_array($indexCache)) {
                $this->routing->init($indexCache);
            } else {
                $this->routing->init($indexCache->get());
            }
        } catch (Throwable $e) {
            Log::error(
                "invalid routing init",
                $e,
                HttpServer::LOG_MODULE_NAME
            );
        }
    }

    /**
     * Handles the incoming HTTP request, routes it, and executes the corresponding endpoint
     *
     * @return Response The response generated by the requested endpoint or an error response
     */
    public function run(): Response
    {
        // Request creation must be deferred until after routing→getRoute completes,
        // as the request→params is read-only and path parameters are unknown beforehand.
        $request = null;

        try {
            try {
                $res     = $this->routing->getRoute($this->method, $this->path);
                $request = $this->makeRequest($res->params);
                return $res->endpoint->run(
                    $request,
                    $this->responseHandler
                );
            } catch (NotFound) {
                $request = is_null($request) ? $this->makeRequest() : $request;
                return $this->notFound($request);
            }
        } catch (Throwable $e) {
            return $this->internalServerError(
                is_null($request) ? $this->makeRequest() : $request,
                $e
            );
        }
    }

    /**
     * Processes and sends the HTTP response to the client.
     *
     * This method handles streaming responses, headers, and post-response tasks
     * while ensuring efficient output buffering and connection handling.
     */
    public function render(): void
    {
        ob_start();
        $response = $this->run();
        $buffer   = ob_get_clean();

        if (!headers_sent()) {
            http_response_code($response->code);
            foreach ($response->getHeaders() as $k => $v) {
                header("$k: $v");
            }
        } else {
            Log::warn(
                "can't to send headers",
                module: self::LOG_MODULE_NAME
            );
        }

        if ($response->body instanceof Generator) {
            // Stream mode: process response body as a generator
            ob_start();
            foreach ($response->body as $el) {
                $b = ob_get_clean();
                if (is_string($b) && strlen($b)) {
                    $buffer .= $b;
                }
                echo $el;
                flush();
                ob_start();
            }
            ob_get_clean();
        } else {
            // Pre-built full response mode: directly output the response body
            echo $response->body;
        }

        // Close HTTP connection with a client
        if ($this->earlyFinishRequest) {
            $this->webServer->finishRequest();
        }

        // Perform post-connection tasks
        // This allows for time-consuming tasks to be performed without leaving the connection to the client open.
        ob_start();
        foreach ($response->getPostProcessCallbacks() as $fn) {
            try {
                $fn();
            } catch (Throwable $e) {
                Log::error(
                    "background after work function returned exception",
                    $e,
                    HttpServer::LOG_MODULE_NAME
                );
            }
        }
        $b = ob_get_clean();
        if (is_string($b) && strlen($b)) {
            $buffer .= $b;
        }

        if (is_string($buffer) && !empty($buffer)) {
            Log::warn(
                "buffer no empty",
                [
                    "buffer" => $buffer
                ],
                self::LOG_MODULE_NAME
            );
        }
    }

    /**
     * Handles 404 Not Found errors.
     *
     * If a custom not found endpoint is set, it will be executed.
     * Otherwise, a default 404 response is returned.
     *
     * @param Request $request The request that resulted in a 404.
     * @return Response The generated response.
     */
    protected function notFound(Request $request): Response
    {
        return $this->notFoundEndpoint instanceof Endpoint ?
            $this->notFoundEndpoint->run($request, $this->responseHandler) :
            new Response("Not found", 404);
    }

    /**
     * Handles 500 Internal Server Error responses.
     *
     * If a custom error handler endpoint is set, it will be executed.
     * Otherwise, a default 500 response is returned.
     *
     * @param Request $request The request that caused the error.
     * @param Throwable $exception The thrown exception.
     * @return Response The generated error response.
     */
    protected function internalServerError(Request $request, Throwable $exception): Response
    {
        Log::error(
            $exception->getMessage(),
            $exception,
            self::LOG_MODULE_NAME
        );

        $request->context->set($exception, self::CONTEXT_EXCEPTION);
        return $this->internalServerErrorEndpoint instanceof Endpoint ?
            $this->internalServerErrorEndpoint->run($request, $this->responseHandler) :
            new Response("Internal server error", 500);
    }

    /**
     * Creates an HTTP request instance based on parsed request data.
     *
     * This method extracts and formats data from the web server for use in routing.
     *
     * @param array $params Optional route parameters extracted from the URL.
     * @return Request The constructed HTTP request object.
     */
    private function makeRequest(array $params = []): Request
    {
        return new Request(
            method: $this->method,
            path: $this->path,
            get: $this->webServer->parseGet(),
            post: $this->webServer->parsePost(),
            cookie: $this->webServer->parseCookie(),
            headers: $this->webServer->parseHeaders(),
            files: $this->webServer->parseFiles(),
            body: $this->webServer->parseRequestBody(),
            params: $params,
        );
    }
}